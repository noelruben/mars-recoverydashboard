<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mars Recovery Station - 3D Visualization</title>
    <style>
        :root {
            --primary: #1a1a2e;
            --secondary: #16213e;
            --accent: #ff6b6b;
            --highlight: #4ecdc4;
            --space-bg: linear-gradient(rgba(10, 10, 30, 0.8), rgba(10, 10, 30, 0.8)),
                        url('https://images.unsplash.com/photo-1615430535007-94da764325d0?ixlib=rb-1.2.1&auto=format&fit=crop&w=1920&q=80');
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--space-bg);
            background-size: cover;
            background-position: center;
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 40px;
            background: rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 1.8rem;
            color: white;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .back-btn, .logout-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            margin-left: 10px;
        }

        .back-btn:hover, .logout-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
        }

        .visualization-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .visualization-header h2 {
            font-size: 2rem;
            color: var(--accent);
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
        }

        .visualization-header p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.1rem;
        }

        #visualization-container {
            width: 100%;
            height: 600px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-card h3 {
            color: var(--accent);
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.3rem;
            border-bottom: 1px solid var(--highlight);
            padding-bottom: 10px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: white;
            text-align: center;
            margin: 15px 0;
            background: linear-gradient(135deg, var(--accent), var(--highlight));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-value small {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            display: block;
            margin-top: 5px;
            background: none;
            -webkit-text-fill-color: initial;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .info-panel h3 {
            color: var(--accent);
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--highlight);
            padding-bottom: 10px;
        }

        @media (max-width: 768px) {
            #visualization-container {
                height: 400px;
            }

            .stats-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/TextureLoader.js"></script>
</head>
<body>
    <div class="header">
        <div>
            <button class="back-btn" onclick="window.location.href='results.html'">
                <i class="fas fa-arrow-left"></i> Back to Results
            </button>
        </div>
        <h1>Mars Recovery Station</h1>
        <button class="logout-btn" onclick="logout()">Logout</button>
    </div>

    <div class="container">
        <div class="visualization-header">
            <h2>3D Recovery Station Visualization</h2>
            <p>Interactive model of the Mars waste recovery facility with realistic terrain</p>
        </div>

        <div id="visualization-container"></div>

        <div class="stats-panel">
            <div class="stat-card">
                <h3>Oxygen Production</h3>
                <div class="stat-value" id="oxygenStat">0<small>kg/day</small></div>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.8); font-size: 0.9rem;">
                    From EVA suits and carbon scraps
                </p>
            </div>

            <div class="stat-card">
                <h3>Material Recovery</h3>
                <div class="stat-value" id="materialStat">0<small>kg/day</small></div>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.8); font-size: 0.9rem;">
                    For 3D printing and repairs
                </p>
            </div>

            <div class="stat-card">
                <h3>Energy Efficiency</h3>
                <div class="stat-value" id="energyStat">0<small>kWh</small></div>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.8); font-size: 0.9rem;">
                    Per processing cycle
                </p>
            </div>
        </div>

        <div class="info-panel">
            <h3>Facility Components</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                <div>
                    <h4 style="color: var(--highlight); margin-bottom: 10px;"><i class="fas fa-industry"></i> Processing Plant</h4>
                    <p style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.8);">
                        Thermal, chemical, and mechanical processing units for waste conversion.
                    </p>
                </div>
                <div>
                    <h4 style="color: var(--highlight); margin-bottom: 10px;"><i class="fas fa-print"></i> 3D Printing Bay</h4>
                    <p style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.8);">
                        Uses recovered materials to manufacture tools and parts on-demand.
                    </p>
                </div>
                <div>
                    <h4 style="color: var(--highlight); margin-bottom: 10px;"><i class="fas fa-solar-panel"></i> Power Station</h4>
                    <p style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.8);">
                        Solar arrays with battery backup for continuous operation.
                    </p>
                </div>
            </div>
        </div>

        <div class="navigation">
            <button class="back-btn" onclick="window.location.href='results.html'">
                <i class="fas fa-arrow-left"></i> Back to Results
            </button>
            <button class="back-btn" onclick="window.location.href='dashboard.html'">
                New Analysis <i class="fas fa-redo"></i>
            </button>
        </div>
    </div>

    <script>
        // Check if user is logged in
        if (localStorage.getItem('isLoggedIn') !== 'true') {
            window.location.href = 'index.html';
        }

        // Logout function
        function logout() {
            localStorage.removeItem('isLoggedIn');
            window.location.href = 'index.html';
        }

        // Load results data
        function loadResultsData() {
            const results = JSON.parse(localStorage.getItem('recyclingResults'));

            if (results) {
                document.getElementById('oxygenStat').textContent = `${results.oxygenRecovered}`;
                document.getElementById('materialStat').textContent = `${results.materialsRecovered}`;
                document.getElementById('energyStat').textContent = `${Math.round(results.totalInput * 1.8)}`;
            }
        }

        // Initialize 3D Visualization with enhanced Mars surface
        document.addEventListener('DOMContentLoaded', function() {
            initEnhanced3DVisualization();
            loadResultsData();
        });

        function initEnhanced3DVisualization() {
            const container = document.getElementById('visualization-container');

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Camera setup - wider view for better perspective
            const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 2000);
            camera.position.set(20, 15, 20);

            // Renderer setup with shadows
            const renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Controls for orbiting the 3D model
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 2, 0);
            controls.maxDistance = 100;
            controls.minDistance = 10;

            // Lighting - simulate Martian sunlight
            const ambientLight = new THREE.AmbientLight(0x404050, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffddcc, 1.2);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Add subtle red light for Mars atmosphere effect
            const marsLight = new THREE.HemisphereLight(0xffaaaa, 0x000055, 0.3);
            scene.add(marsLight);

            // Create enhanced Mars surface with elevation
            createEnhancedMars(scene);

            // Create detailed recovery station
            createDetailedRecoveryStation(scene);

            // Add stars to the background
            createStarfield(scene, 2000);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            // Handle window resize
            window.addEventListener('resize', function() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            animate();
        }

        function createEnhancedMars(scene) {
            // High-resolution Mars texture
            const marsTexture = new THREE.TextureLoader().load('https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/OSIRIS_Mars_true_color.jpg/1200px-OSIRIS_Mars_true_color.jpg');

            // Mars elevation map for realistic terrain
            const marsElevation = new THREE.TextureLoader().load('https://upload.wikimedia.org/wikipedia/commons/thumb/5/5f/Mars_topography.jpg/1200px-Mars_topography.jpg');

            // Create Mars sphere with bump mapping for realistic terrain
            const marsGeometry = new THREE.SphereGeometry(15, 128, 128);
            const marsMaterial = new THREE.MeshStandardMaterial({
                map: marsTexture,
                bumpMap: marsElevation,
                bumpScale: 0.05,
                metalness: 0.1,
                roughness: 0.8,
                color: 0xcc9966
            });

            const mars = new THREE.Mesh(marsGeometry, marsMaterial);
            mars.receiveShadow = true;
            scene.add(mars);

            // Add subtle atmosphere effect
            const atmosphereGeometry = new THREE.SphereGeometry(15.2, 64, 64);
            const atmosphereMaterial = new THREE.MeshStandardMaterial({
                color: 0x3366cc,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide,
                roughness: 0.1
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);

            // Add some surface features (craters)
            addSurfaceFeatures(scene, mars);
        }

        function addSurfaceFeatures(scene, mars) {
            // Add some random craters to make the surface more realistic
            const craterGeometry = new THREE.CircleGeometry(0.3, 32);
            const craterMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                side: THREE.DoubleSide,
                roughness: 0.9
            });

            for (let i = 0; i < 50; i++) {
                const crater = new THREE.Mesh(craterGeometry, craterMaterial);

                // Random position on Mars surface
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 15 + (Math.random() * 0.2 - 0.1);

                crater.position.x = radius * Math.sin(phi) * Math.cos(theta);
                crater.position.y = radius * Math.sin(phi) * Math.sin(theta);
                crater.position.z = radius * Math.cos(phi);

                // Orient crater to face away from Mars center
                crater.lookAt(0, 0, 0);

                // Random size variation
                const scale = 0.5 + Math.random() * 0.5;
                crater.scale.set(scale, scale, scale);

                // Random depth
                crater.position.x += (Math.random() - 0.5) * 0.1;
                crater.position.y += (Math.random() - 0.5) * 0.1;
                crater.position.z += (Math.random() - 0.5) * 0.1;

                scene.add(crater);
            }
        }

        function createDetailedRecoveryStation(scene) {
            // Base platform with more detail
            const baseGroup = new THREE.Group();
            baseGroup.position.set(0, 0.1, 0);

            // Main base
            const baseGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.3,
                roughness: 0.7
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.receiveShadow = true;
            base.castShadow = true;
            baseGroup.add(base);

            // Add support legs
            const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 16);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.5,
                roughness: 0.6
            });

            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4;
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.x = Math.cos(angle) * 2.5;
                leg.position.z = Math.sin(angle) * 2.5;
                leg.position.y = -0.75;
                leg.rotation.x = Math.PI / 4;
                leg.castShadow = true;
                baseGroup.add(leg);
            }

            // Main habitat dome with more detail
            const domeGroup = new THREE.Group();
            domeGroup.position.y = 1.5;

            // Dome base
            const domeBaseGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 32);
            const domeBaseMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                metalness: 0.2,
                roughness: 0.5
            });
            const domeBase = new THREE.Mesh(domeBaseGeometry, domeBaseMaterial);
            domeBase.castShadow = true;
            domeGroup.add(domeBase);

            // Dome itself
            const domeGeometry = new THREE.SphereGeometry(1.5, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                metalness: 0.2,
                roughness: 0.5,
                transparent: true,
                opacity: 0.7
            });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.y = 0.3;
            dome.castShadow = true;
            domeGroup.add(dome);

            // Add airlock
            const airlockGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 32);
            const airlockMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                metalness: 0.4,
                roughness: 0.5
            });
            const airlock = new THREE.Mesh(airlockGeometry, airlockMaterial);
            airlock.position.set(1.8, 0.5, 0);
            airlock.rotation.z = Math.PI / 2;
            airlock.castShadow = true;
            domeGroup.add(airlock);

            baseGroup.add(domeGroup);

            // Solar panels array with more detail
            const solarArray = new THREE.Group();
            solarArray.position.set(0, 2, -4);

            const panelGeometry = new THREE.BoxGeometry(1.5, 0.02, 0.5);
            const panelMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                metalness: 0.7,
                roughness: 0.2,
                side: THREE.DoubleSide
            });

            // Create an array of solar panels
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 5; col++) {
                    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                    panel.position.x = col * 1.6 - 3.2;
                    panel.position.z = row * 0.6 - 0.6;
                    panel.rotation.x = Math.PI / 4 + (Math.random() - 0.5) * 0.1;
                    panel.castShadow = true;
                    solarArray.add(panel);
                }
            }

            baseGroup.add(solarArray);

            // Processing units with more detail
            const processingGroup = new THREE.Group();
            processingGroup.position.set(0, 0.5, 3);

            // Thermal processor
            createProcessorUnit(processingGroup, -1.5, 0, 0, 0xff5555, 'Thermal Processor');
            // Chemical processor
            createProcessorUnit(processingGroup, 0, 0, 1.5, 0x55ff55, 'Chemical Processor');
            // Mechanical processor
            createProcessorUnit(processingGroup, 1.5, 0, 0, 0x5555ff, 'Mechanical Processor');

            baseGroup.add(processingGroup);

            // Storage tanks with pipes
            const storageGroup = new THREE.Group();
            storageGroup.position.set(4, 0.5, 0);

            // Oxygen tank
            createStorageTank(storageGroup, 0, 0, 0.8, 'Oxygen Tank');
            // Material tank
            createStorageTank(storageGroup, 0, 0, -0.8, 'Material Tank');

            // Connecting pipes
            createPipe(storageGroup, -0.5, 0.5, 0, 0.5, 0.5, -0.8, 0.1);
            createPipe(storageGroup, 0.5, 0.5, 0, 0.5, 0.5, -0.8, 0.1);

            baseGroup.add(storageGroup);

            // Add the complete base group to the scene
            scene.add(baseGroup);

            // Add some rovers for scale
            addRovers(scene);
        }

        function createProcessorUnit(group, x, y, z, color, name) {
            const unitGroup = new THREE.Group();
            unitGroup.position.set(x, y, z);

            // Main cylinder
            const cylinderGeometry = new THREE.CylinderGeometry(0.6, 0.6, 1.2, 32);
            const cylinderMaterial = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.6,
                roughness: 0.3
            });
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.castShadow = true;
            unitGroup.add(cylinder);

            // Top sphere
            const sphereGeometry = new THREE.SphereGeometry(0.4, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.7,
                roughness: 0.2
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.y = 0.7;
            sphere.castShadow = true;
            unitGroup.add(sphere);

            // Add some pipes
            const pipeGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 16);
            const pipeMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                metalness: 0.8,
                roughness: 0.3
            });

            // Input pipe
            const inputPipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
            inputPipe.position.set(0.4, 0, 0);
            inputPipe.rotation.z = Math.PI / 2;
            unitGroup.add(inputPipe);

            // Output pipe
            const outputPipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
            outputPipe.position.set(-0.4, 0, 0);
            outputPipe.rotation.z = Math.PI / 2;
            unitGroup.add(outputPipe);

            group.add(unitGroup);
        }

        function createStorageTank(group, x, y, z, name) {
            const tankGroup = new THREE.Group();
            tankGroup.position.set(x, y, z);

            // Main sphere
            const sphereGeometry = new THREE.SphereGeometry(0.7, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: name.includes('Oxygen') ? 0xaaaaff : 0xffaaaa,
                metalness: 0.3,
                roughness: 0.7,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.castShadow = true;
            tankGroup.add(sphere);

            // Support legs
            const legGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 16);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.5,
                roughness: 0.6
            });

            for (let i = 0; i < 3; i++) {
                const angle = (i * Math.PI * 2) / 3;
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.x = Math.cos(angle) * 0.6;
                leg.position.z = Math.sin(angle) * 0.6;
                leg.position.y = -0.7;
                leg.rotation.x = Math.PI / 4;
                leg.castShadow = true;
                tankGroup.add(leg);
            }

            // Input/output pipes
            const pipeGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 16);
            const pipeMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                metalness: 0.8,
                roughness: 0.3
            });

            const topPipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
            topPipe.position.y = 0.8;
            topPipe.rotation.x = Math.PI / 2;
            tankGroup.add(topPipe);

            group.add(tankGroup);
        }

        function createPipe(group, x1, y1, z1, x2, y2, z2, radius) {
            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(x1, y1, z1),
                new THREE.Vector3((x1 + x2) / 2, (y1 + y2) / 2 + 0.3, (z1 + z2) / 2),
                new THREE.Vector3(x2, y2, z2)
            );

            const points = curve.getPoints(50);
            const pipeGeometry = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(points),
                50,
                radius,
                8,
                false
            );

            const pipeMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                metalness: 0.8,
                roughness: 0.3
            });

            const pipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
            pipe.castShadow = true;
            group.add(pipe);
        }

        function addRovers(scene) {
            // Simple rover model
            const roverGroup1 = new THREE.Group();
            roverGroup1.position.set(8, 0.5, -5);
            roverGroup1.rotation.y = Math.PI / 4;

            // Rover body
            const bodyGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                metalness: 0.3,
                roughness: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            roverGroup1.add(body);

            // Rover wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.4,
                roughness: 0.6
            });

            // Front wheels
            const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontLeftWheel.position.set(0.3, -0.2, 0.2);
            frontLeftWheel.rotation.z = Math.PI / 2;
            roverGroup1.add(frontLeftWheel);

            const frontRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontRightWheel.position.set(0.3, -0.2, -0.2);
            frontRightWheel.rotation.z = Math.PI / 2;
            roverGroup1.add(frontRightWheel);

            // Rear wheels
            const rearLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rearLeftWheel.position.set(-0.3, -0.2, 0.2);
            rearLeftWheel.rotation.z = Math.PI / 2;
            roverGroup1.add(rearLeftWheel);

            const rearRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rearRightWheel.position.set(-0.3, -0.2, -0.2);
            rearRightWheel.rotation.z = Math.PI / 2;
            roverGroup1.add(rearRightWheel);

            // Solar panel
            const panelGeometry = new THREE.BoxGeometry(0.6, 0.02, 0.3);
            const panelMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                metalness: 0.7,
                roughness: 0.2
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            panel.position.set(0, 0.2, 0);
            panel.rotation.x = Math.PI / 4;
            roverGroup1.add(panel);

            scene.add(roverGroup1);

            // Second rover
            const roverGroup2 = new THREE.Group();
            roverGroup2.position.set(-10, 0.5, 3);
            roverGroup2.rotation.y = -Math.PI / 3;

            const body2 = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body2.castShadow = true;
            roverGroup2.add(body2);

            // Wheels for second rover
            const flWheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            flWheel2.position.set(0.3, -0.2, 0.2);
            flWheel2.rotation.z = Math.PI / 2;
            roverGroup2.add(flWheel2);

            const frWheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frWheel2.position.set(0.3, -0.2, -0.2);
            frWheel2.rotation.z = Math.PI / 2;
            roverGroup2.add(frWheel2);

            const rlWheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rlWheel2.position.set(-0.3, -0.2, 0.2);
            rlWheel2.rotation.z = Math.PI / 2;
            roverGroup2.add(rlWheel2);

            const rrWheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rrWheel2.position.set(-0.3, -0.2, -0.2);
            rrWheel2.rotation.z = Math.PI / 2;
            roverGroup2.add(rrWheel2);

            const panel2 = new THREE.Mesh(panelGeometry, panelMaterial);
            panel2.position.set(0, 0.2, 0);
            panel2.rotation.x = Math.PI / 4;
            roverGroup2.add(panel2);

            scene.add(roverGroup2);
        }

        function createStarfield(scene, count) {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });

            const positions = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Random position in a sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 800 + Math.random() * 200;

                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }
    </script>
</body>
</html>
